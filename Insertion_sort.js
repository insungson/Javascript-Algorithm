//삽입 정렬: 첫 숫자는 놔두고, 두 번째 자리 숫자부터 뽑아서 그 숫자가 첫 숫자보다 크면 
//          첫 숫자 오른쪽에, 작으면 왼쪽에 넣습니다. 세 번째 자리 숫자를 뽑아서 앞의 
//          두 숫자와 크기를 비교해서 알맞은 자리에 넣습니다. 이렇게 끝까지 계속하면 정렬됩니다.
//https://www.zerocho.com/category/Algorithm/post/57e39fca76a7850015e6944a

var insertionSort = function(array){
    var i=1, temp, j;
    for(i; i<array.length; i++){
        temp = array[i];
        for(j=i-1; j>=0 && temp<array[j]; j--){//j>=0 에서 =까지 넣어야 첫번째 인자가 -1이 되서 바꿀수 있다.
            array[j+1]=array[j];
        }
        array[j+1] = temp;
    }
    return array;
};
console.log(insertionSort([5, 6, 1, 2, 4, 3]));

// [5, 6, 1, 2, 4, 3]
// [5, 6, 6, 2, 4, 3]
// [5, 5, 6, 2, 4, 3]
// [1, 5, 6, 2, 4, 3]

// [1, 5, 6, 2, 4, 3]
// [1, 5, 6, 6, 4, 3]
// [1, 5, 5, 6, 4, 3]
// [1, 2, 5, 6, 4, 3]

// [1, 2, 5, 6, 4, 3]
// [1, 2, 5, 6, 6, 3]
// [1, 2, 5, 5, 6, 3]
// [1, 2, 4, 5, 6, 3]

// [1, 2, 4, 5, 6, 3]
// [1, 2, 4, 5, 6, 6]
// [1, 2, 4, 5, 5, 6]
// [1, 2, 4, 4, 5, 6]
// [1, 2, 3, 4, 5, 6]


//삽입 정렬은 성능이 뛰어난 정렬은 아닙니다. 
//작은 수에서만 효과적인 경우가 많습니다. 
//첫 번째로 배우는 이유는 간단하기 때문입니다. 
//또한 이미 정렬되어 있는 배열에 새로운 원소를 집어넣어 다시 정렬할 때는 매우 효과적입니다. 
//새 원소를 처음부터 한번씩만 기존의 원소들과 비교하면 되니까요.

//보통 반복문을 두 번 중첩해서 돌면 성능이 그리 좋지 않습니다. 
//정렬이 효과적인지 아닌지 판단하려면 복잡도라는 개념을 알아야합니다

// 복잡도는 https://www.zerocho.com/category/Algorithm/post/57ea2987fdea850015313534 를 보자